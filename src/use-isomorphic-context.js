import {useContext, useLayoutEffect, useRef, useState} from 'react';

import {HydrationContext} from './context';
import {noImmediateStateOnHydrationError, noImmediateStateOnRenderError, noImmediateStateOnServerError} from './errors';

export default function useIsomorphicContext(context, isEqual) {
    if (process.browser) {
        const hydrationContext = useContext(HydrationContext);
        const {data$, name, elementId} = useContext(context);
        const subscription = useRef(null);

        let immediateState = null;

        const observer = useRef((value) => {
            immediateState = value;
        });

        const [state, setState] = useState(() => {
            subscription.current = (
                isEqual
                    ? data$.skipDuplicates(isEqual)
                    : data$
            )
                .onValue((value) => {
                    observer.current(value);
                });

            if (!immediateState) {
                subscription.current();
                subscription.current = null;

                if (process.env.NODE_ENV === 'development') {
                    if (hydrationContext) {
                        console.warn(noImmediateStateOnHydrationError(name, elementId));
                    } else {
                        console.warn(noImmediateStateOnRenderError(name));
                    }
                }
            }

            return immediateState;
        });

        useLayoutEffect(() => {
            observer.current = (value) => {
                setState(value);
            };

            return () => {
                if (subscription.current) {
                    subscription.current();
                }
            };
        }, []);

        return state;
    } else {
        const {data$, name} = useContext(context);
        const [state] = useState(() => {
            let immediateState = null;

            // Subscribe and unsubscribe to get an immediate value from the stream.
            // If we're *really* server-side, data$ is generated by bacon.constant from the initial value produced by
            // getData when it eventually resolves, so this should *always* produce initial state.
            // Nevertheless, it's possible not to have an initial state according to the explanation in the error
            // message a few lines down.
            data$.onValue((value) => {
                immediateState = value;
            })();

            if (process.env.NODE_ENV === 'development' && !immediateState) {
                console.error(noImmediateStateOnServerError(name));
            }

            return immediateState;
        });

        return state;
    }
}
