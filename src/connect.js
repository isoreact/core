import React from 'react';
import propTypes from 'prop-types';
import bacon from 'baconjs';

import {HydrationContext} from './context';
import {noImmediateStateOnHydrationError, noImmediateStateOnRenderError, noImmediateStateOnServerError} from './errors';

class Connector extends React.Component {
    static propTypes = {
        createElement: propTypes.func.isRequired,
        data$: propTypes.instanceOf(bacon.Observable).isRequired,
        isEqual: propTypes.func,
        name: propTypes.string.isRequired,
        elementId: propTypes.string,
    };

    static contextType = HydrationContext;

    constructor(props, context) {
        super(props, context);

        if (process.browser) {
            // Use the immediately produced stream event to set initial state.
            this.observer = (value) => {
                this.state = value;
            };

            this.unsubscribe = (
                props.isEqual
                    ? props.data$.skipDuplicates(props.isEqual)
                    : props.data$
            )
                .onValue((value) => {
                    this.observer(value);
                });

            // If the stream didn't immediately produce an event, we have no initial state, so we can't hydrate.
            // Client-side, getData should produce an event immediately and, when hydrating, use the hydration object to
            // generate its value.
            if (!this.state) {
                this.unsubscribe();
                this.unsubscribe = undefined;

                if (process.env.NODE_ENV === 'development') {
                    if (context) { // eslint-disable-line max-depth
                        console.warn(noImmediateStateOnHydrationError(props.name, props.elementId));
                    } else {
                        console.warn(noImmediateStateOnRenderError(props.name));
                    }
                }
            }
        } else {
            // Subscribe and unsubscribe to get an immediate value from the stream.
            // If we're *really* server-side, data$ is generated by bacon.constant from the initial value produced by
            // getData when it eventually resolves, so this should *always* produce initial state.
            // Nevertheless, it's possible not to have an initial state when we're using the server build in the
            // browser.
            props.data$
                .onValue((value) => {
                    this.state = value; // eslint-disable-line react/no-direct-mutation-state
                })();

            if (process.env.NODE_ENV === 'development' && !this.state) {
                console.error(noImmediateStateOnServerError(name));
            }
        }
    }

    componentDidMount() {
        this.observer = (value) => {
            this.setState(value);
        };
    }

    componentWillUnmount() {
        if (this.unsubscribe) {
            this.unsubscribe();
        }
    }

    render() {
        return this.state
            ? this.props.createElement(this.state)
            : null;
    }
}

export default function Connect({
    context: Context,
    isEqual,
    children,
}) {
    return (
        <Context.Consumer>
            {({data$, name, elementId}) => (
                <Connector
                    createElement={children}
                    {...{data$, isEqual, name, elementId}}
                />
            )}
        </Context.Consumer>
    );
}

Connect.propTypes = {

    /** React context for all instances of this component */
    context: propTypes.object.isRequired,

    /** If provided: Given two consecutive states, a and b, skip state b if isEqual(a, b). */
    isEqual: propTypes.func,

    /** A function that converts isomorphic component state into React elements */
    children: propTypes.func.isRequired,
};
